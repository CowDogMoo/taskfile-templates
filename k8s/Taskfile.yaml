---
version: "3"

tasks:
  destroy-stuck-ns:
    desc: "Remove finalizers from stuck Kubernetes namespaces"
    vars:
      PROXY_PORT: '{{ .PROXY_PORT | default "8001" }}'
    cmds:
      - |
        # Find all namespaces in Terminating state
        TERMINATING_NS=$(kubectl get ns --field-selector status.phase=Terminating -o jsonpath='{.items[*].metadata.name}')
        if [ -z "$TERMINATING_NS" ]; then
            echo "No stuck namespaces found"
            exit 0
        fi
        echo "Found stuck namespaces: $TERMINATING_NS"

        cleanup_proxy() {
            local proxy_pid=$1
            local proxy_port=$2
            if [ ! -z "$proxy_pid" ]; then
                # Kill the proxy and any child processes
                pkill -P $proxy_pid 2>/dev/null || true
                kill -9 $proxy_pid 2>/dev/null || true
                # Ensure no hanging processes
                if command -v lsof >/dev/null 2>&1; then
                    lsof -ti :$proxy_port | xargs -r kill -9 2>/dev/null || true
                else
                    fuser -k $proxy_port/tcp 2>/dev/null || true
                fi
            fi
        }

        # Kill any existing proxy on the port
        if command -v lsof >/dev/null 2>&1; then
            lsof -ti :{{ .PROXY_PORT }} | xargs -r kill -9 2>/dev/null || true
        else
            fuser -k {{ .PROXY_PORT }}/tcp 2>/dev/null || true
        fi

        # Process each namespace sequentially
        for ns in $TERMINATING_NS; do
            echo "Removing finalizers from namespace: $ns"

            # Retry loop to handle conflicts (409 errors)
            for attempt in {1..5}; do
                # Get the latest namespace definition
                if ! kubectl get namespace $ns -o json > "tmp_$ns.json"; then
                    echo "Failed to fetch namespace $ns, skipping."
                    break
                fi

                # Remove finalizers if they exist
                jq '.spec.finalizers = []' "tmp_$ns.json" > "tmp_clean_$ns.json"

                # Start proxy with cleanup
                kubectl proxy --port={{ .PROXY_PORT }} &
                PROXY_PID=$!

                # Wait for proxy to be ready
                for i in $(seq 1 10); do
                    if curl -s http://127.0.0.1:{{ .PROXY_PORT }} >/dev/null; then
                        break
                    fi
                    if [ $i -eq 10 ]; then
                        echo "Proxy failed to start for namespace: $ns"
                        cleanup_proxy $PROXY_PID {{ .PROXY_PORT }}
                        exit 1
                    fi
                    sleep 1
                done

                # Attempt to update the namespace
                RESPONSE=$(curl -s -w "%{http_code}" -o /dev/null -k -H "Content-Type: application/json" -X PUT --data-binary @"tmp_clean_$ns.json" \
                    http://127.0.0.1:{{ .PROXY_PORT }}/api/v1/namespaces/$ns/finalize)

                cleanup_proxy $PROXY_PID {{ .PROXY_PORT }}

                if [[ "$RESPONSE" == "200" ]]; then
                    echo "Successfully updated namespace: $ns"
                    break
                elif [[ "$RESPONSE" == "409" ]]; then
                    echo "Conflict detected for $ns (attempt $attempt). Retrying..."
                    sleep 2
                else
                    echo "Failed to update namespace: $ns with HTTP response $RESPONSE"
                    exit 1
                fi
            done

            rm -f "tmp_$ns.json" "tmp_clean_$ns.json"
            echo "Completed processing namespace: $ns"
        done

        echo "All stuck namespaces have been processed"

  list-node-pods:
    desc: "List all pods running on a specific node across all namespaces"
    vars:
      NODE_NAME: '{{ .NODE_NAME | default "node1" }}'
    cmds:
      - kubectl get pods --all-namespaces --field-selector spec.nodeName={{ .NODE_NAME }} -o wide
