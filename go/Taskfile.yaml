---
# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

vars:
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
  COMMIT:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "unknown"
  DATE:
    sh: date -u +%Y-%m-%dT%H:%M:%SZ
  LDFLAGS: -s -w -X main.version={{.VERSION}} -X main.commit={{.COMMIT}} -X main.date={{.DATE}}
  HOST_OS:
    sh: go env GOOS
  HOST_ARCH:
    sh: go env GOARCH
  # Customize these for your project
  BINARY_NAME: '{{.BINARY_NAME | default "app"}}'
  CMD_PATH: '{{.CMD_PATH | default "./cmd"}}'

tasks:
  default:
    desc: Build, test, and clean
    cmds:
      - task: clean
      - task: build
      - task: test

  build:
    desc: Build binary (OS=linux|darwin|windows ARCH=amd64|arm64|arm GOARM=7)
    vars:
      OS: '{{.OS | default .HOST_OS}}'
      ARCH: '{{.ARCH | default .HOST_ARCH}}'
      GOARM: '{{.GOARM | default ""}}'
      OUTPUT_DIR: '{{if eq .OS .HOST_OS}}{{if eq .ARCH .HOST_ARCH}}.{{else}}dist{{end}}{{else}}dist{{end}}'
      EXT: '{{if eq .OS "windows"}}.exe{{end}}'
      SUFFIX: '{{if eq .OS .HOST_OS}}{{if eq .ARCH .HOST_ARCH}}{{else}}-{{.OS}}-{{.ARCH}}{{if .GOARM}}v{{.GOARM}}{{end}}{{end}}{{else}}-{{.OS}}-{{.ARCH}}{{if .GOARM}}v{{.GOARM}}{{end}}{{end}}'
      OUTPUT: '{{.OUTPUT_DIR}}/{{.BINARY_NAME}}{{.SUFFIX}}{{.EXT}}'
    deps:
      - tidy
    cmds:
      - mkdir -p {{.OUTPUT_DIR}}
      - echo "Building {{.BINARY_NAME}} for {{.OS}}/{{.ARCH}}{{if .GOARM}}v{{.GOARM}}{{end}}"
      - GOOS={{.OS}} GOARCH={{.ARCH}}{{if .GOARM}} GOARM={{.GOARM}}{{end}} go build -ldflags "{{.LDFLAGS}}" -o {{.OUTPUT}} {{.CMD_PATH}}
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
      - internal/**/*.go
      - "*.go"
      - go.mod
      - go.sum
    generates:
      - "{{.OUTPUT}}"

  build-all:
    desc: Build for all supported platforms
    cmds:
      - task: build
        vars: { OS: linux, ARCH: amd64 }
      - task: build
        vars: { OS: linux, ARCH: arm64 }
      - task: build
        vars: { OS: linux, ARCH: arm, GOARM: "7" }
      - task: build
        vars: { OS: darwin, ARCH: amd64 }
      - task: build
        vars: { OS: darwin, ARCH: arm64 }
      - task: build
        vars: { OS: windows, ARCH: amd64 }

  clean:
    desc: Clean build artifacts
    cmds:
      - rm -f {{.BINARY_NAME}}
      - rm -rf dist/
      - go clean

  test:
    desc: Run tests
    cmds:
      - go test -v -race -coverprofile=coverage.out ./...

  test-coverage:
    desc: Run tests with coverage report
    deps:
      - test
    cmds:
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"

  coverage:
    desc: Show test coverage table and overall percentage
    cmds:
      - |
        go test -coverprofile=/tmp/{{.BINARY_NAME}}-cover.out ./... 2>&1 | \
          awk 'BEGIN {printf "| %-40s | %-10s |\n|------------------------------------------|------------|\n", "Package", "Coverage"}
               /coverage:/ {
                 for(i=1;i<=NF;i++) {
                   if($i ~ /^github\.com\// || $i ~ /^[a-z]+\.[a-z]+\//) pkg=$i
                   if($i ~ /%/) pct=$i
                 }
                 n=split(pkg,parts,"/")
                 printf "| %-40s | %10s |\n", pkg, pct
               }'
        echo ""
        go tool cover -func=/tmp/{{.BINARY_NAME}}-cover.out | tail -1 | awk '{printf "Overall: %s\n", $NF}'

  lint:
    desc: Run linter (requires golangci-lint)
    cmds:
      - golangci-lint run ./...

  fmt:
    desc: Format code
    cmds:
      - go fmt ./...

  tidy:
    desc: Tidy dependencies
    cmds:
      - go mod tidy

  install:
    desc: Install binary to GOPATH/bin
    deps:
      - tidy
    cmds:
      - go install -ldflags "{{.LDFLAGS}}" {{.CMD_PATH}}
      - echo "Installed to $(go env GOPATH)/bin/{{.BINARY_NAME}}"

  show-arch:
    desc: Show detected architecture and build strategy
    cmds:
      - echo "Host OS{{":"}} {{.HOST_OS}}"
      - echo "Host ARCH{{":"}} {{.HOST_ARCH}}"
      - echo "Version{{":"}} {{.VERSION}}"
      - echo "Build strategy{{":"}} native"

  run:
    desc: Build and run binary
    deps:
      - build
    cmds:
      - ./{{.BINARY_NAME}} {{.CLI_ARGS}}

  dev:
    desc: Run in development mode with verbose logging
    deps:
      - build
    cmds:
      - ./{{.BINARY_NAME}} --verbose {{.CLI_ARGS}}

  # CI/CD specific tasks
  ci-test:
    desc: Run tests for CI/CD (with JSON output)
    cmds:
      - go test -v -race -coverprofile=coverage.out -json ./... > test-results.json
      - go tool cover -func=coverage.out

  ci-build:
    desc: Build for CI/CD environment
    cmds:
      - task: build
      - task: test
      - echo "Build completed successfully"

  # Architecture-specific CI tasks
  ci-build-native:
    desc: Build for native architecture in CI
    cmds:
      - echo "Building for native arch{{":"}} {{.HOST_ARCH}}"
      - task: build
      - file {{.BINARY_NAME}} || true

  ci-matrix:
    desc: Show build matrix for CI/CD
    cmds:
      - |
        echo "Recommended CI/CD build matrix:"
        echo "  - arch: amd64"
        echo "    runner: ubuntu-latest"
        echo "    strategy: native"
        echo ""
        echo "  - arch: arm64"
        echo "    runner: ubuntu-24.04-arm"
        echo "    strategy: native"

  # Release tasks
  release:
    desc: Create and push a new release tag (triggers goreleaser GHA)
    vars:
      TAG: '{{.TAG | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
      - sh: '[ -n "{{.TAG}}" ]'
        msg: "TAG is required. Usage: task release TAG=v1.0.0"
      - sh: git diff --quiet
        msg: "Working directory is not clean. Commit or stash changes first."
      - sh: git diff --cached --quiet
        msg: "Staged changes detected. Commit or unstage changes first."
    cmds:
      - echo "Creating release tag {{.TAG}}..."
      - git tag -a {{.TAG}} -m "Release {{.TAG}}"
      - echo "Pushing tag {{.TAG}} to remote..."
      - git push origin {{.TAG}}
      - echo "Tag pushed successfully. GoReleaser GitHub Action will build and publish the release."
      - echo "Monitor the release at$(":")"
      - gh run list --workflow=goreleaser.yaml --limit 1

  release-check:
    desc: Check if a release exists and view its status
    vars:
      TAG: '{{.TAG | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
    cmds:
      - |
        if [ -n "{{.TAG}}" ]; then
          echo "Checking release status for {{.TAG}}..."
          gh release view {{.TAG}} || echo "Release {{.TAG}} not found"
        else
          echo "Latest releases:"
          gh release list --limit 5
        fi

  release-watch:
    desc: Watch the goreleaser workflow run in real-time
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
    cmds:
      - |
        echo "Watching latest goreleaser workflow run..."
        RUN_ID=$(gh run list --workflow=goreleaser.yaml --limit 1 --json databaseId --jq '.[0].databaseId')
        if [ -n "$RUN_ID" ]; then
          gh run watch $RUN_ID
        else
          echo "No goreleaser workflow runs found"
        fi

  release-test:
    desc: Test goreleaser locally (snapshot build, no publish)
    preconditions:
      - sh: command -v goreleaser
        msg: "goreleaser is required. Install from https://goreleaser.com/install/"
    cmds:
      - echo "Running goreleaser in snapshot mode (no publish)..."
      - goreleaser release --snapshot --clean --skip=publish
      - echo "Snapshot build completed. Check dist/ directory for artifacts."

  release-draft:
    desc: Create a draft release with gh CLI
    vars:
      TAG: '{{.TAG | default ""}}'
      TITLE: '{{.TITLE | default .TAG}}'
      NOTES: '{{.NOTES | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
      - sh: '[ -n "{{.TAG}}" ]'
        msg: "TAG is required. Usage: task release-draft TAG=v1.0.0"
    cmds:
      - |
        echo "Creating draft release for {{.TAG}}..."
        if [ -n "{{.NOTES}}" ]; then
          gh release create {{.TAG}} --draft --title "{{.TITLE}}" --notes "{{.NOTES}}"
        else
          gh release create {{.TAG}} --draft --title "{{.TITLE}}" --generate-notes
        fi
        echo "Draft release created. Edit and publish it at:"
        gh release view {{.TAG}} --web

  release-delete:
    desc: Delete a release and its tag
    vars:
      TAG: '{{.TAG | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
      - sh: '[ -n "{{.TAG}}" ]'
        msg: "TAG is required. Usage: task release-delete TAG=v1.0.0"
    prompt: "Are you sure you want to delete release {{.TAG}}? This will also delete the git tag."
    cmds:
      - echo "Deleting release {{.TAG}}..."
      - gh release delete {{.TAG}} --yes || echo "Release not found on GitHub"
      - echo "Deleting local tag {{.TAG}}..."
      - git tag -d {{.TAG}} || echo "Local tag not found"
      - echo "Deleting remote tag {{.TAG}}..."
      - git push origin :refs/tags/{{.TAG}} || echo "Remote tag not found"
      - echo "Release and tag deleted successfully."

  release-changelog:
    desc: Generate changelog between two tags
    vars:
      FROM: '{{.FROM | default ""}}'
      TO: '{{.TO | default "HEAD"}}'
    cmds:
      - |
        if [ -z "{{.FROM}}" ]; then
          # Get the latest tag if FROM not specified
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous tags found. Showing all commits:"
            git log --oneline --decorate
          else
            echo "Changelog since $LATEST_TAG:"
            git log ${LATEST_TAG}..{{.TO}} --oneline --decorate
          fi
        else
          echo "Changelog from {{.FROM}} to {{.TO}}:"
          git log {{.FROM}}..{{.TO}} --oneline --decorate
        fi
