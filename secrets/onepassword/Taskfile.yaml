---
# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

tasks:
  ensure-dependencies:
    desc: "Verify that 1Password CLI is installed"
    cmds:
      - |
        if ! command -v op &> /dev/null; then
          echo "'op' command not found. Please install 1Password CLI: https://developer.1password.com/docs/cli/get-started"
          exit 1
        fi

  setup-account:
    desc: "Set up 1Password CLI and authenticate with your account"
    deps:
      - ensure-dependencies
    vars:
      OP_ACCOUNT: "{{.OP_ACCOUNT | default \"my\"}}"
    cmds:
      - |
        # Ensure the op config directory exists
        mkdir -p "${HOME}/.config/op"

        # Check if we have an account specified
        if [ -z "{{.OP_ACCOUNT}}" ]; then
          echo "Please specify your 1Password account domain using the OP_ACCOUNT variable."
          echo "Example: task setup-account OP_ACCOUNT=my-team.1password.com"
          exit 1
        fi

        # Check if already signed in by using 'op whoami'
        if user_info=$(op whoami --account "{{.OP_ACCOUNT}}" 2>/dev/null); then
          # Extract email from whoami output
          email=$(echo "$user_info" | grep "Email:" | awk '{print $2}')

          echo "âœ… Already signed in to 1Password account {{.OP_ACCOUNT}}"
          echo "   Account email: $email"
          echo "   Your 1Password CLI is ready to use"
        else
          # Sign in to 1Password account
          echo "Setting up 1Password CLI with account {{.OP_ACCOUNT}}"
          op account add --address "{{.OP_ACCOUNT}}"

          echo "âœ… 1Password account setup complete."
          echo "   Use 'op signin' to authenticate your session."
          echo "   To verify your setup, run: op whoami"
        fi

  list-vaults:
    desc: "List all vaults in your 1Password account"
    deps:
      - ensure-dependencies
    cmds:
      - op vault list

  list-secrets:
    desc: "List secrets in a vault"
    deps:
      - ensure-dependencies
    vars:
      VAULT_NAME: "{{.VAULT_NAME | default \"\"}}"
      CATEGORY: "{{.CATEGORY | default \"\"}}"
    cmds:
      - |
        # Prepare vault filter if provided
        VAULT_FILTER=""
        if [ -n "{{.VAULT_NAME}}" ]; then
          VAULT_FILTER="--vault=\"{{.VAULT_NAME}}\""
        fi

        # Prepare category filter if provided
        CATEGORY_FILTER=""
        if [ -n "{{.CATEGORY}}" ]; then
          CATEGORY_FILTER="--categories=\"{{.CATEGORY}}\""
        fi

        # List the items
        eval "op item list $VAULT_FILTER $CATEGORY_FILTER"

  get-secret:
    desc: "Retrieve a secret from 1Password (by ID or name)"
    deps:
      - ensure-dependencies
    cmds:
      - |
        # Check required parameters
        if [ -z "{{.SECRET_NAME}}" ]; then
          echo "Please specify the secret name using the SECRET_NAME variable."
          exit 1
        fi

        # Check if signed in by using 'op whoami'
        if ! op whoami &>/dev/null; then
          echo "âŒ Not signed in to 1Password. Please run 'task setup-account OP_ACCOUNT=your-account' first."
          exit 1
        fi

        # Check if jq is installed - it's needed for proper JSON parsing
        if ! command -v jq &> /dev/null; then
          echo "âš ï¸ 'jq' command not found. Using fallback method. For better reliability, install jq."
          JQ_AVAILABLE=false
        else
          JQ_AVAILABLE=true
        fi

        # Prepare vault filter if provided
        VAULT_FILTER=""
        if [ -n "{{.VAULT}}" ]; then
          VAULT_FILTER="--vault=\"{{.VAULT}}\""
        fi

        # Determine password field (default to "password" or try with custom field if specified)
        PASSWORD_FIELD="{{.FIELD}}"
        if [ -z "$PASSWORD_FIELD" ]; then
          PASSWORD_FIELD="password"
        fi

        FORMAT="{{.FORMAT}}"
        if [ -z "$FORMAT" ]; then
          FORMAT="json"
        fi

        # First, let's try to get information about the item to see its structure
        if [[ "{{.SECRET_NAME}}" =~ ^[a-zA-Z0-9]{26}$ ]]; then
          # This looks like an ID
          echo "ðŸ” Looking up item with ID: {{.SECRET_NAME}}"
          ITEM_INFO=$(op item get "{{.SECRET_NAME}}" --format=json 2>/dev/null)
        else
          # This looks like a name
          echo "ðŸ” Looking up item with name: {{.SECRET_NAME}}"
          if [ -n "{{.VAULT}}" ]; then
            ITEM_INFO=$(op item get "{{.SECRET_NAME}}" --vault="{{.VAULT}}" --format=json 2>/dev/null)
          else
            ITEM_INFO=$(op item get "{{.SECRET_NAME}}" --format=json 2>/dev/null)
          fi
        fi

        # If we found the item, extract its details and get the requested field
        if [ -n "$ITEM_INFO" ]; then
          # Extract item details based on whether jq is available
          if [ "$JQ_AVAILABLE" = true ]; then
            # Use jq for reliable JSON parsing
            ITEM_ID=$(echo "$ITEM_INFO" | jq -r '.id')
            ITEM_TITLE=$(echo "$ITEM_INFO" | jq -r '.title')
            ITEM_VAULT=$(echo "$ITEM_INFO" | jq -r '.vault.id')
            ITEM_VAULT_NAME=$(echo "$ITEM_INFO" | jq -r '.vault.name')

            # Debug: Print all fields and their purposes
            echo "ðŸ“‹ Available fields and their purposes:"
            echo "$ITEM_INFO" | jq -r '.fields[] | "   - \(.id): \(.purpose) (\(.type))"'

            # Extract password directly using 'purpose: PASSWORD'
            if [ "$PASSWORD_FIELD" = "password" ]; then
              # Try to find field with PURPOSE=PASSWORD first
              PASSWORD_ID=$(echo "$ITEM_INFO" | jq -r '.fields[] | select(.purpose=="PASSWORD") | .id')
              if [ -n "$PASSWORD_ID" ]; then
                echo "ðŸ”‘ Found password field with ID: $PASSWORD_ID"
                PASSWORD_FIELD="$PASSWORD_ID"
              fi
            fi
          else
            # Fallback to grep pattern matching (less reliable)
            ITEM_ID=$(echo "$ITEM_INFO" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
            ITEM_TITLE=$(echo "$ITEM_INFO" | grep -o '"title":"[^"]*"' | head -1 | cut -d'"' -f4)
            ITEM_VAULT=$(echo "$ITEM_INFO" | grep -o '"vault":{[^}]*}' | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
            ITEM_VAULT_NAME=$(echo "$ITEM_INFO" | grep -o '"vault":{[^}]*}' | grep -o '"name":"[^"]*"' | head -1 | cut -d'"' -f4)
          fi

          echo "âœ… Found item: $ITEM_TITLE (ID: $ITEM_ID) in vault: $ITEM_VAULT_NAME"

          # Now retrieve the secret using the specific ID or title
          if [ -z "{{.OUTPUT_FILE}}" ]; then
            # Try multiple methods to get the password, starting with the most reliable

            # Method 1: Get by item ID and field ID directly
            if [ "$JQ_AVAILABLE" = true ] && [ -n "$PASSWORD_ID" ]; then
              echo "ðŸ“¤ Trying to get password by item ID and field ID..."
              SECRET_VALUE=$(op item get "$ITEM_ID" --fields "$PASSWORD_ID" --reveal 2>/dev/null)
              if [ $? -eq 0 ] && [ -n "$SECRET_VALUE" ]; then
                echo "âœ… Secret retrieved successfully (Method 1)"
                echo "$SECRET_VALUE"
                exit 0
              fi
            fi

            # Method 2: Get by item ID and field label
            echo "ðŸ“¤ Trying to get password by item ID and field label..."
            SECRET_VALUE=$(op item get "$ITEM_ID" --fields "$PASSWORD_FIELD" --reveal 2>/dev/null)
            if [ $? -eq 0 ] && [ -n "$SECRET_VALUE" ]; then
              echo "âœ… Secret retrieved successfully (Method 2)"
              echo "$SECRET_VALUE"
              exit 0
            fi

            # Method 3: Get using the reference path from the JSON
            if [ "$JQ_AVAILABLE" = true ]; then
              REF_PATH=$(echo "$ITEM_INFO" | jq -r --arg field "$PASSWORD_FIELD" '.fields[] | select(.id==$field or .label==$field) | .reference')
              if [ -n "$REF_PATH" ] && [ "$REF_PATH" != "null" ]; then
                echo "ðŸ“¤ Trying to get password using reference path: $REF_PATH"
                SECRET_VALUE=$(op read "$REF_PATH" --reveal 2>/dev/null)
                if [ $? -eq 0 ] && [ -n "$SECRET_VALUE" ]; then
                  echo "âœ… Secret retrieved successfully (Method 3)"
                  echo "$SECRET_VALUE"
                  exit 0
                fi
              fi
            fi

            # Method 4: Last resort - try to get the entire item and parse manually
            echo "ðŸ“¤ Trying alternative method to get password..."
            if [ "$FORMAT" = "text" ]; then
              op item get "$ITEM_ID" --format="$FORMAT" --reveal
              exit $?
            else
              # Try to get all fields as JSON and parse later
              op item get "$ITEM_ID" --reveal
              exit $?
            fi
          else
            # Save to file
            OUTPUT_PATH=$(eval echo "{{.OUTPUT_FILE}}")
            if op item get "$ITEM_ID" --fields "$PASSWORD_FIELD" > "$OUTPUT_PATH" 2>/dev/null; then
              echo "âœ… Secret saved to $OUTPUT_PATH"
              exit 0
            else
              echo "âŒ Failed to save secret to file. Trying alternative method..."
              if op item get "$ITEM_ID" > "$OUTPUT_PATH" 2>/dev/null; then
                echo "âœ… Full item saved to $OUTPUT_PATH (you'll need to extract the password manually)"
                exit 0
              fi
            fi
          fi

          echo "âŒ All methods to extract password failed."
          echo "ðŸ’¡ Try using the op client directly:"
          echo "  op item get \"$ITEM_TITLE\" --vault=\"$ITEM_VAULT_NAME\""
        else
          echo "âŒ Item not found. Please check if '{{.SECRET_NAME}}' exists and you have access."

          # For debugging: list available items to help the user
          echo ""
          echo "Available items (first 10):"
          op item list --limit 10 | head -10
        fi

        exit 1

  create-vault:
    desc: "Create a new vault in 1Password"
    deps:
      - ensure-dependencies
    cmds:
      - |
        # Ensure VAULT_NAME is provided
        if [ -z "{{.VAULT_NAME}}" ]; then
          echo "Please specify the vault name using the VAULT_NAME variable."
          echo "Example: task create-vault VAULT_NAME=Development"
          exit 1
        fi

        # Create the vault
        echo "Creating new vault named '{{.VAULT_NAME}}'"
        op vault create "{{.VAULT_NAME}}"

        echo "Vault '{{.VAULT_NAME}}' created successfully."

  create-item:
    desc: "Create any 1Password item using templates (Login, Secure Note, Password, etc.)"
    deps:
      - ensure-dependencies
    vars:
      CATEGORY: "{{.CATEGORY | default \"\"}}"
      TITLE: "{{.TITLE | default \"\"}}"
      VAULT_NAME: "{{.VAULT_NAME | default \"\"}}"
      FIELDS: "{{.FIELDS | default \"\"}}"
      URL: "{{.URL | default \"\"}}"
      TAGS: "{{.TAGS | default \"\"}}"
    cmds:
      - |
        # Check for jq (required for JSON manipulation)
        if ! command -v jq &> /dev/null; then
          echo "âŒ Error: 'jq' is required for this task. Please install jq."
          echo "   macOS: brew install jq"
          echo "   Ubuntu/Debian: apt-get install jq"
          exit 1
        fi

        # Check required parameters
        if [ -z "{{.CATEGORY}}" ]; then
          echo "âŒ Error: CATEGORY parameter is required"
          echo ""
          echo "Usage: task onepassword:create-item CATEGORY='Login' TITLE='My Item' VAULT_NAME='Personal' FIELDS='username=john,password=secret'"
          echo ""
          echo "Available categories:"
          op item template list | tail -n +2 | awk '{print "  - " $2}'
          exit 1
        fi

        if [ -z "{{.TITLE}}" ]; then
          echo "âŒ Error: TITLE parameter is required"
          exit 1
        fi

        if [ -z "{{.VAULT_NAME}}" ]; then
          echo "âŒ Error: VAULT_NAME parameter is required"
          exit 1
        fi

        echo "Creating {{.CATEGORY}} item '{{.TITLE}}' in vault '{{.VAULT_NAME}}'..."

        # Fetch the template for the category
        TEMPLATE=$(op item template get "{{.CATEGORY}}" 2>/dev/null)
        if [ $? -ne 0 ]; then
          echo "âŒ Error: Failed to fetch template for category '{{.CATEGORY}}'"
          echo "   Available categories:"
          op item template list | tail -n +2 | awk '{print "  - " $2}'
          exit 1
        fi

        # Set the title
        TEMPLATE=$(echo "$TEMPLATE" | jq --arg title "{{.TITLE}}" '.title = $title')

        # Parse and add fields
        FIELDS_STRING="{{.FIELDS}}"
        if [ -n "$FIELDS_STRING" ]; then
          while [ -n "$FIELDS_STRING" ]; do
            # Extract first field (split on comma - handle escaping later if needed)
            FIELD="${FIELDS_STRING%%,*}"

            # Remove first field from string
            if [ "$FIELDS_STRING" = "$FIELD" ]; then
              FIELDS_STRING=""
            else
              FIELDS_STRING="${FIELDS_STRING#*,}"
            fi

            # Skip empty fields
            if [ -z "$FIELD" ]; then
              continue
            fi

            # Split field into key=value[:type]
            KEY="${FIELD%%=*}"
            VALUE_AND_TYPE="${FIELD#*=}"

            # Check if there's a type specification (field=value:type)
            if echo "$VALUE_AND_TYPE" | grep -q ":"; then
              VALUE="${VALUE_AND_TYPE%:*}"
              TYPE="${VALUE_AND_TYPE##*:}"
            else
              VALUE="$VALUE_AND_TYPE"
              TYPE=""
            fi

            if [ -z "$KEY" ] || [ -z "$VALUE" ] || [ "$KEY" = "$VALUE_AND_TYPE" ]; then
              continue
            fi

            # Check if this is a built-in field in the template
            FIELD_EXISTS=$(echo "$TEMPLATE" | jq --arg key "$KEY" '.fields[] | select(.id == $key) | .id' -r)

            if [ -n "$FIELD_EXISTS" ]; then
              # Update existing built-in field
              TEMPLATE=$(echo "$TEMPLATE" | jq --arg key "$KEY" --arg value "$VALUE" \
                '(.fields[] | select(.id == $key) | .value) = $value')
              echo "  âœ“ Set built-in field '$KEY'"
            else
              # Add as custom field
              if [ -z "$TYPE" ]; then
                TYPE="text"
              fi

              # Map type names to 1Password JSON type names
              case "$TYPE" in
                text) JSON_TYPE="STRING" ;;
                password) JSON_TYPE="CONCEALED" ;;
                email) JSON_TYPE="EMAIL" ;;
                url) JSON_TYPE="URL" ;;
                date) JSON_TYPE="DATE" ;;
                monthYear) JSON_TYPE="MONTH_YEAR" ;;
                phone) JSON_TYPE="PHONE" ;;
                otp) JSON_TYPE="OTP" ;;
                *) JSON_TYPE="STRING" ;;
              esac

              # Add custom field
              TEMPLATE=$(echo "$TEMPLATE" | jq --arg label "$KEY" --arg value "$VALUE" --arg type "$JSON_TYPE" \
                '.fields += [{"label": $label, "type": $type, "value": $value}]')
              echo "  âœ“ Added custom field '$KEY' (type: $TYPE)"
            fi
          done
        fi

        # Add URL if provided (for Login items)
        if [ -n "{{.URL}}" ]; then
          TEMPLATE=$(echo "$TEMPLATE" | jq --arg url "{{.URL}}" \
            '.urls = [{"label": "website", "primary": true, "href": $url}]')
          echo "  âœ“ Set primary URL: {{.URL}}"
        fi

        # Add tags if provided
        if [ -n "{{.TAGS}}" ]; then
          # Convert comma-separated tags to JSON array
          TAGS_ARRAY=$(echo "{{.TAGS}}" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$"; ""))')
          TEMPLATE=$(echo "$TEMPLATE" | jq --argjson tags "$TAGS_ARRAY" '.tags = $tags')
          echo "  âœ“ Added tags: {{.TAGS}}"
        fi

        # Create a temporary file for the template
        TEMP_FILE=$(mktemp)
        echo "$TEMPLATE" > "$TEMP_FILE"

        # Debug: show the template being used
        if [ -n "$DEBUG" ]; then
          echo "Template JSON:"
          cat "$TEMP_FILE" | jq .
        fi

        # Create the item using the template
        if op item create --template "$TEMP_FILE" --vault "{{.VAULT_NAME}}" > /dev/null 2>&1; then
          echo "âœ… {{.CATEGORY}} item '{{.TITLE}}' created successfully!"
        else
          echo "âŒ Failed to create item"
          echo "   Template file: $TEMP_FILE (preserved for debugging)"
          exit 1
        fi

        # Clean up temp file
        rm -f "$TEMP_FILE"

  create-secure-note:
    desc: "Create a secure note in 1Password with custom fields"
    deps:
      - ensure-dependencies
    vars:
      ITEM_TITLE: "{{.ITEM_TITLE | default \"\"}}"
      VAULT_NAME: "{{.VAULT_NAME | default \"\"}}"
      FIELDS: "{{.FIELDS | default \"\"}}"
    cmds:
      - |
        # Check required parameters
        if [ -z "{{.ITEM_TITLE}}" ]; then
          echo "âŒ Error: ITEM_TITLE parameter is required"
          echo ""
          echo "Usage: task onepassword:create-secure-note ITEM_TITLE=my-item VAULT_NAME=my-vault FIELDS='field1=value1,field2=value2'"
          exit 1
        fi

        if [ -z "{{.VAULT_NAME}}" ]; then
          echo "âŒ Error: VAULT_NAME parameter is required"
          exit 1
        fi

        if [ -z "{{.FIELDS}}" ]; then
          echo "âŒ Error: FIELDS parameter is required"
          echo "   Format: FIELDS='field1=value1||field2=value2'"
          exit 1
        fi

        echo "Creating secure note '{{.ITEM_TITLE}}' in vault '{{.VAULT_NAME}}'..."

        # Build the op item create command with fields
        CMD="op item create --category='Secure Note' --title='{{.ITEM_TITLE}}' --vault='{{.VAULT_NAME}}'"

        # Parse FIELDS and add each field to the command (using || as delimiter)
        FIELDS_STRING="{{.FIELDS}}"
        while [ -n "$FIELDS_STRING" ]; do
          # Extract first field (split on ||)
          FIELD="${FIELDS_STRING%%||*}"

          # Remove first field from string
          if [ "$FIELDS_STRING" = "$FIELD" ]; then
            FIELDS_STRING=""
          else
            FIELDS_STRING="${FIELDS_STRING#*||}"
          fi

          # Split field into key=value
          KEY="${FIELD%%=*}"
          VALUE="${FIELD#*=}"

          # Check if value has a type suffix (e.g., "mypassword:password")
          if echo "$VALUE" | grep -q ":"; then
            FIELD_VALUE="${VALUE%:*}"
            FIELD_TYPE="${VALUE##*:}"
          else
            FIELD_VALUE="$VALUE"
            FIELD_TYPE="text"
          fi

          # Allow empty values for fields (but not empty keys)
          if [ -n "$KEY" ] && [ "$KEY" != "$VALUE" ]; then
            if [ -z "$FIELD_VALUE" ]; then
              # For empty values, explicitly set to empty string with double quotes
              CMD="$CMD '$KEY[$FIELD_TYPE]=\"\"'"
            else
              # For non-empty values, use regular quoting
              CMD="$CMD $KEY[$FIELD_TYPE]='$FIELD_VALUE'"
            fi
          fi
        done

        # Execute the command
        eval "$CMD"

        if [ $? -eq 0 ]; then
          echo "âœ… Secure note '{{.ITEM_TITLE}}' created successfully!"
        else
          echo "âŒ Failed to create secure note"
          exit 1
        fi

  delete-item:
    desc: "Delete an item from 1Password"
    deps:
      - ensure-dependencies
    vars:
      ITEM_TITLE: "{{.ITEM_TITLE | default \"\"}}"
      VAULT_NAME: "{{.VAULT_NAME | default \"\"}}"
    prompt: "Are you sure you want to delete '{{.ITEM_TITLE}}'?"
    cmds:
      - |
        # Check required parameters
        if [ -z "{{.ITEM_TITLE}}" ]; then
          echo "âŒ Error: ITEM_TITLE parameter is required"
          echo ""
          echo "Usage: task onepassword:delete-item ITEM_TITLE=my-item VAULT_NAME=my-vault"
          exit 1
        fi

        # Prepare vault filter if provided
        VAULT_FILTER=""
        if [ -n "{{.VAULT_NAME}}" ]; then
          VAULT_FILTER="--vault='{{.VAULT_NAME}}'"
        fi

        echo "Deleting item '{{.ITEM_TITLE}}'..."

        # Delete the item
        eval "op item delete '{{.ITEM_TITLE}}' $VAULT_FILTER"

        if [ $? -eq 0 ]; then
          echo "âœ… Item '{{.ITEM_TITLE}}' deleted successfully!"
        else
          echo "âŒ Failed to delete item"
          exit 1
        fi

  # encrypt-file:
  #   desc: "Encrypt a file using 1Password"
  #   deps:
  #     - ensure-dependencies
  #   vars:
  #     INPUT_FILE: "{{.INPUT_FILE | default \"\"}}"
  #     OUTPUT_FILE: "{{.OUTPUT_FILE | default \"\"}}"
  #     VAULT_NAME: "{{.VAULT_NAME | default \"\"}}"
  #     DOCUMENT_TITLE: "{{.DOCUMENT_TITLE | default \"\"}}"
  #   cmds:
  #     - |
  #       # Ensure INPUT_FILE is provided
  #       if [ -z "{{.INPUT_FILE}}" ]; then
  #         echo "Please specify the input file to encrypt using the INPUT_FILE variable."
  #         exit 1
  #       fi

  #       # Expand the tilde in input path
  #       INPUT_PATH=$(eval echo "{{.INPUT_FILE}}")

  #       # Set document title if not provided
  #       if [ -z "{{.DOCUMENT_TITLE}}" ]; then
  #         DOCUMENT_TITLE=$(basename "$INPUT_PATH")
  #       else
  #         DOCUMENT_TITLE="{{.DOCUMENT_TITLE}}"
  #       fi

  #       # Prepare vault filter if provided
  #       VAULT_FILTER=""
  #       if [ -n "{{.VAULT_NAME}}" ]; then
  #         VAULT_FILTER="--vault=\"{{.VAULT_NAME}}\""
  #       fi

  #       # Store the file in 1Password
  #       eval "op document create \"$INPUT_PATH\" --title=\"$DOCUMENT_TITLE\" $VAULT_FILTER"

  #       # If OUTPUT_FILE is specified, also create a .op reference file
  #       if [ -n "{{.OUTPUT_FILE}}" ]; then
  #         OUTPUT_PATH=$(eval echo "{{.OUTPUT_FILE}}")
  #         echo "# This file is stored in 1Password" > "$OUTPUT_PATH"
  #         echo "# Title: $DOCUMENT_TITLE" >> "$OUTPUT_PATH"
  #         echo "# To retrieve: task decrypt-file DOCUMENT_TITLE=\"$DOCUMENT_TITLE\"" >> "$OUTPUT_PATH"
  #         echo "File encrypted and reference saved to $OUTPUT_PATH"
  #       fi

  # decrypt-file:
  #   desc: "Decrypt a file from 1Password"
  #   deps:
  #     - ensure-dependencies
  #   vars:
  #     DOCUMENT_TITLE: "{{.DOCUMENT_TITLE | default \"\"}}"
  #     DOCUMENT_ID: "{{.DOCUMENT_ID | default \"\"}}"
  #     OUTPUT_FILE: "{{.OUTPUT_FILE | default \"\"}}"
  #     VAULT_NAME: "{{.VAULT_NAME | default \"\"}}"
  #   cmds:
  #     - |
  #       # Ensure either DOCUMENT_TITLE or DOCUMENT_ID is provided
  #       if [ -z "{{.DOCUMENT_TITLE}}" ] && [ -z "{{.DOCUMENT_ID}}" ]; then
  #         echo "Please specify either the document title using DOCUMENT_TITLE or the document ID using DOCUMENT_ID."
  #         exit 1
  #       fi

  #       # Prepare vault filter if provided
  #       VAULT_FILTER=""
  #       if [ -n "{{.VAULT_NAME}}" ]; then
  #         VAULT_FILTER="--vault=\"{{.VAULT_NAME}}\""
  #       fi

  #       # Set identifier based on what was provided
  #       if [ -n "{{.DOCUMENT_TITLE}}" ]; then
  #         IDENTIFIER="{{.DOCUMENT_TITLE}}"
  #       else
  #         IDENTIFIER="{{.DOCUMENT_ID}}"
  #       fi

  #       # Set OUTPUT_FILE if not provided
  #       if [ -z "{{.OUTPUT_FILE}}" ]; then
  #         if [ -n "{{.DOCUMENT_TITLE}}" ]; then
  #           OUTPUT_FILE="{{.DOCUMENT_TITLE}}"
  #         else
  #           OUTPUT_FILE="document_from_1password"
  #         fi
  #       else
  #         OUTPUT_FILE=$(eval echo "{{.OUTPUT_FILE}}")
  #       fi

  #       # Retrieve the document from 1Password
  #       eval "op document get \"$IDENTIFIER\" $VAULT_FILTER --output=\"$OUTPUT_FILE\""

  #       echo "Document retrieved and saved to $OUTPUT_FILE"

  # delete-secret:
  #   desc: "Delete a secret from 1Password"
  #   deps:
  #     - ensure-dependencies
  #   vars:
  #     SECRET_NAME: "{{.SECRET_NAME | default \"\"}}"
  #     VAULT_NAME: "{{.VAULT_NAME | default \"\"}}"
  #   cmds:
  #     - |
  #       # Check required parameters
  #       if [ -z "{{.SECRET_NAME}}" ]; then
  #         echo "Please specify the secret name using the SECRET_NAME variable."
  #         exit 1
  #       fi

  #       # Prepare vault filter if provided
  #       VAULT_FILTER=""
  #       if [ -n "{{.VAULT_NAME}}" ]; then
  #         VAULT_FILTER="--vault=\"{{.VAULT_NAME}}\""
  #       fi

  #       # Ask for confirmation
  #       read -p "Are you sure you want to delete '{{.SECRET_NAME}}'? (y/N) " -n 1 -r
  #       echo    # Move to a new line
  #       if [[ $REPLY =~ ^[Yy]$ ]]; then
  #         # Delete the secret
  #         eval "op item delete \"{{.SECRET_NAME}}\" $VAULT_FILTER"
  #         echo "Secret '{{.SECRET_NAME}}' deleted."
  #       else
  #         echo "Operation cancelled."
  #       fi
