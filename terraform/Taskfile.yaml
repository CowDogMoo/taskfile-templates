---
# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

tasks:
  check-terraform:
    desc: Validate that Terraform is installed
    cmds:
      - |
        if ! command -v terraform &> /dev/null; then
          echo "'terraform' command not found. Please install Terraform: https://www.terraform.io/downloads.html"
          exit 1
        fi
    silent: true

  check-terragrunt:
    desc: Validate that Terragrunt is installed
    cmds:
      - |
        if ! command -v terragrunt &> /dev/null; then
          echo "'terragrunt' command not found. Please install Terragrunt: https://terragrunt.gruntwork.io"
          exit 1
        fi
    silent: true

  lint:
    desc: Run terraform fmt check and tflint on all terraform files
    deps:
      - check-terraform
    cmds:
      - |
        echo "Running terraform fmt check"
        terraform fmt -check -recursive
        echo "Running tflint"
        find . -type f -name "*.tf" -exec dirname {} \; | uniq | while read dir; do
          (cd "$dir" && tflint)
        done
    silent: true

  terragrunt-base:
    internal: true
    deps:
      - check-terraform
      - check-terragrunt
    vars:
      AUTO_APPROVE: '{{.AUTO_APPROVE | default "true"}}'
      BASE_PATH: '{{.BASE_PATH | default "./"}}'
      COMMAND: '{{.COMMAND}}'
      DEPLOYMENT: '{{.DEPLOYMENT | default ""}}'
      ENV: '{{.ENV | default ""}}'
      MODULE: '{{.MODULE | default ""}}'
      REGION: '{{.REGION | default (env "AWS_DEFAULT_REGION")}}'
      VERBOSE: '{{.VERBOSE | default "false"}}'
    cmds:
      - |
        set -euo pipefail

        # Check for required COMMAND variable
        if [ -z "{{.COMMAND}}" ]; then
          echo "ERROR: COMMAND variable is not set"
          exit 1
        fi

        # Validate required variables
        if [ -z "{{ .DEPLOYMENT }}" ] || [ -z "{{ .ENV }}" ] || [ -z "{{ .REGION }}" ]; then
          echo "ERROR: DEPLOYMENT, ENV, and REGION variables are required"
          exit 1
        fi

        # Construct base path
        WORKING_DIR=$(pwd)
        BASE_PATH="{{ .BASE_PATH }}"
        FULL_PATH="$WORKING_DIR/$BASE_PATH/{{ .DEPLOYMENT }}/{{ .ENV }}/{{ .REGION }}"

        if [ ! -d "$FULL_PATH" ]; then
          echo "ERROR: Directory does not exist: $FULL_PATH"
          exit 1
        fi

        echo "Using path: $FULL_PATH"

        # Configure terragrunt flags
        FLAGS="--non-interactive -lock=false"

        # Add verbose/debug logging if requested
        if [ "{{.VERBOSE}}" = "true" ]; then
          # Use --log-level debug for detailed Terragrunt logging
          FLAGS="$FLAGS --log-level debug"

          # Also enable Terraform debug logging
          export TF_LOG=DEBUG

          # Optionally, you can use --log-format for different output styles
          # FLAGS="$FLAGS --log-format key-value"
        else
          # Use bare format for cleaner output when not in verbose mode
          FLAGS="$FLAGS --log-format bare"
        fi

        # Only add -auto-approve for apply and destroy commands
        if [ "{{.AUTO_APPROVE | default "false" }}" = "true" ] && ( [ "{{.COMMAND}}" = "apply" ] || [ "{{.COMMAND}}" = "destroy" ] ); then
          FLAGS="$FLAGS -auto-approve"
        fi

        if [ "{{.COMMAND}}" = "init" ]; then
          FLAGS="$FLAGS -upgrade"
        fi

        # Execute terragrunt command
        if [ -n "{{ .MODULE }}" ]; then
          echo "Running terragrunt {{.COMMAND}} for module: {{.MODULE}}"

          # Check if the module path is a directory that contains subdirectories with terragrunt.hcl files
          if [ -d "$FULL_PATH/{{.MODULE}}" ] && find "$FULL_PATH/{{.MODULE}}" -name "terragrunt.hcl" -type f | grep -q .; then
            # If it's a directory with terragrunt.hcl files in subdirectories, use --all
            echo "Module is a directory containing Terragrunt modules, using --all"
            cd "$FULL_PATH/{{.MODULE}}"
            terragrunt {{.COMMAND}} $FLAGS --all
          elif [ "{{.COMMAND}}" = "destroy" ]; then
            terragrunt {{.COMMAND}} $FLAGS --all \
              --working-dir "$FULL_PATH/{{.MODULE}}"
          else
            terragrunt {{.COMMAND}} $FLAGS \
              --working-dir "$FULL_PATH/{{.MODULE}}"
          fi
        else
          echo "Running terragrunt {{.COMMAND}} --all for all modules"
          terragrunt {{.COMMAND}} $FLAGS --all \
            --working-dir "$FULL_PATH"
        fi
    silent: true

  terragrunt-init:
    desc: Initialize a specific module in a given environment using Terragrunt
    vars:
      COMMAND: init
    cmds:
      - task: terragrunt-base
        vars:
          AUTO_APPROVE: '{{.AUTO_APPROVE}}'
          BASE_PATH: '{{.BASE_PATH}}'
          COMMAND: '{{.COMMAND}}'
          DEPLOYMENT: '{{.DEPLOYMENT}}'
          ENV: '{{.ENV}}'
          REGION: '{{.REGION}}'
          MODULE: '{{.MODULE}}'
    silent: true

  terragrunt-plan:
    desc: Plan changes to a specific module in a given environment using Terragrunt
    vars:
      COMMAND: plan
    cmds:
      - task: terragrunt-base
        vars:
          AUTO_APPROVE: '{{.AUTO_APPROVE}}'
          BASE_PATH: '{{.BASE_PATH}}'
          COMMAND: '{{.COMMAND}}'
          DEPLOYMENT: '{{.DEPLOYMENT}}'
          ENV: '{{.ENV}}'
          REGION: '{{.REGION}}'
          MODULE: '{{.MODULE}}'
    silent: true

  terragrunt-apply:
    desc: Apply a specific module in a given environment using Terragrunt
    vars:
      COMMAND: apply
    cmds:
      - task: terragrunt-base
        vars:
          AUTO_APPROVE: '{{.AUTO_APPROVE}}'
          BASE_PATH: '{{.BASE_PATH}}'
          COMMAND: '{{.COMMAND}}'
          DEPLOYMENT: '{{.DEPLOYMENT}}'
          ENV: '{{.ENV}}'
          REGION: '{{.REGION}}'
          MODULE: '{{.MODULE}}'
    silent: true

  terragrunt-destroy:
    desc: Destroy a specific module in a given environment using Terragrunt
    vars:
      COMMAND: destroy
    cmds:
      - task: terragrunt-base
        vars:
          AUTO_APPROVE: '{{.AUTO_APPROVE}}'
          BASE_PATH: '{{.BASE_PATH}}'
          COMMAND: '{{.COMMAND}}'
          DEPLOYMENT: '{{.DEPLOYMENT}}'
          ENV: '{{.ENV}}'
          REGION: '{{.REGION}}'
          MODULE: '{{.MODULE}}'
    silent: true

  terratest-init:
    desc: Simple terraform init for tests
    deps:
      - check-terraform
    cmds:
      - terraform init -upgrade
    silent: true

  run-terratest:
    desc: Run Terratest for infrastructure testing
    deps:
      - check-terraform
      - terratest-init
    vars:
      TIMEOUT: '{{.TIMEOUT | default "60m"}}'
      DESTROY: '{{.DESTROY | default "true"}}'
      VERBOSE: '{{.VERBOSE | default "false"}}'
      LOG_TO_FILE: '{{.LOG_TO_FILE | default "false"}}'
      LOG_PATH: '{{.LOG_PATH | default "/tmp/terratest.log"}}'
    cmds:
      - |
        cd test
        go mod tidy
        export TERRATEST_DESTROY={{.DESTROY}}

        # Set up logging based on verbosity and logging preferences
        if [ "{{.VERBOSE}}" = "true" ]; then
          export TF_LOG=DEBUG
          if [ "{{.LOG_TO_FILE}}" = "true" ]; then
            export TF_LOG_PATH=./terraform.log
            go test -v -test.v -timeout={{.TIMEOUT}} | tee {{.LOG_PATH}}
          else
            go test -v -test.v -timeout={{.TIMEOUT}}
          fi
        else
          if [ "{{.LOG_TO_FILE}}" = "true" ]; then
            go test -timeout={{.TIMEOUT}} | tee {{.LOG_PATH}}
          else
            go test -timeout={{.TIMEOUT}}
          fi
        fi
    silent: true

  validate:
    desc: Run Terraform validate to ensure configuration is syntactically correct
    deps:
      - check-terraform
    cmds:
      - |
        terraform validate
    silent: true

  format:
    desc: Format Terraform code
    deps:
      - check-terraform
    cmds:
      - |
        terraform fmt -recursive
    silent: true

  terragrunt-state-remove-all:
      desc: Remove all resources from the Terraform state for a specific module
      deps:
        - check-terraform
        - check-terragrunt
      vars:
        BASE_PATH: '{{.BASE_PATH | default "./"}}'
        DEPLOYMENT: '{{.DEPLOYMENT}}'
        ENV: '{{.ENV}}'
        MODULE: '{{.MODULE}}'
        REGION: '{{.REGION | default (env "AWS_DEFAULT_REGION")}}'
      cmds:
        - |
          set -eo pipefail

          # Validate required variables
          if [ -z "{{ .DEPLOYMENT }}" ] || [ -z "{{ .ENV }}" ] || [ -z "{{ .REGION }}" ]; then
            echo "ERROR: DEPLOYMENT, ENV, and REGION variables are required"
            exit 1
          fi

          # Construct base path
          WORKING_DIR=$(pwd)
          BASE_PATH="{{ .BASE_PATH }}"
          FULL_PATH="$WORKING_DIR/$BASE_PATH/{{ .DEPLOYMENT }}/{{ .ENV }}/{{ .REGION }}"

          if [ ! -d "$FULL_PATH" ]; then
            echo "ERROR: Directory does not exist: $FULL_PATH"
            exit 1
          fi

          echo "Using path: $FULL_PATH"

          if [ -n "{{ .MODULE }}" ]; then
            echo "Removing all state resources for module: {{.MODULE}}"
            cd "$FULL_PATH/{{.MODULE}}"
          else
            echo "Removing all state resources from root module"
            cd "$FULL_PATH"
          fi

          # List all resources and remove them one by one
          terragrunt state list | sed 's/"/\\"/g' | xargs -I {} terragrunt state rm "{}"

      silent: true

  terraform-init:
    desc: Initialize a specific module in a given environment using Terraform
    deps:
      - check-terraform
    vars:
      BASE_PATH: '{{.BASE_PATH | default "./"}}'
      DEPLOYMENT: '{{.DEPLOYMENT | default ""}}'
      ENV: '{{.ENV | default ""}}'
      MODULE: '{{.MODULE | default ""}}'
      REGION: '{{.REGION | default (env "AWS_DEFAULT_REGION")}}'
    cmds:
      - |
        set -euo pipefail

        # Validate required variables
        if [ -z "{{ .DEPLOYMENT }}" ] || [ -z "{{ .ENV }}" ] || [ -z "{{ .REGION }}" ]; then
          echo "ERROR: DEPLOYMENT, ENV, and REGION variables are required"
          exit 1
        fi

        # Construct base path
        WORKING_DIR=$(pwd)
        BASE_PATH="{{ .BASE_PATH }}"
        FULL_PATH="$WORKING_DIR/$BASE_PATH/{{ .DEPLOYMENT }}/{{ .ENV }}/{{ .REGION }}"

        if [ ! -d "$FULL_PATH" ]; then
          echo "ERROR: Directory does not exist: $FULL_PATH"
          exit 1
        fi

        echo "Using path: $FULL_PATH"

        # Configure terraform init flags
        FLAGS="-upgrade"

        # Execute terraform init command
        if [ -n "{{ .MODULE }}" ]; then
          echo "Running terraform init for module: {{.MODULE}}"

          MODULE_PATH="$FULL_PATH/{{.MODULE}}"

          if [ ! -d "$MODULE_PATH" ]; then
            echo "ERROR: Module directory does not exist: $MODULE_PATH"
            exit 1
          fi

          cd "$MODULE_PATH"
          terraform init $FLAGS
        else
          echo "Running terraform init in root directory"
          cd "$FULL_PATH"
          terraform init $FLAGS
        fi
    silent: true

  terraform-plan:
    desc: Run terraform plan with tfvars file
    deps:
      - check-terraform
    vars:
      VAR_FILE: '{{.VAR_FILE | default "terraform.tfvars"}}'
      VERBOSE: '{{.VERBOSE | default "false"}}'
    cmds:
      - |
        set -euo pipefail

        # Enable verbose logging if requested
        if [ "{{.VERBOSE}}" = "true" ]; then
          export TF_LOG=DEBUG
        fi

        # Check if var file exists
        if [ -f "{{.VAR_FILE}}" ]; then
          echo "Running terraform plan with {{.VAR_FILE}}"
          terraform plan -var-file={{.VAR_FILE}}
        else
          echo "Running terraform plan (no var file found)"
          terraform plan
        fi
    silent: false

  terraform-apply:
    desc: Run terraform apply with tfvars file
    deps:
      - check-terraform
    vars:
      VAR_FILE: '{{.VAR_FILE | default "terraform.tfvars"}}'
      AUTO_APPROVE: '{{.AUTO_APPROVE | default "false"}}'
      VERBOSE: '{{.VERBOSE | default "false"}}'
    cmds:
      - |
        set -euo pipefail

        # Enable verbose logging if requested
        if [ "{{.VERBOSE}}" = "true" ]; then
          export TF_LOG=DEBUG
        fi

        # Build command flags
        FLAGS=""
        if [ "{{.AUTO_APPROVE}}" = "true" ]; then
          FLAGS="-auto-approve"
        fi

        # Check if var file exists
        if [ -f "{{.VAR_FILE}}" ]; then
          echo "Running terraform apply with {{.VAR_FILE}}"
          terraform apply -var-file={{.VAR_FILE}} $FLAGS
        else
          echo "Running terraform apply (no var file found)"
          terraform apply $FLAGS
        fi
    silent: false

  terraform-destroy:
    desc: Run terraform destroy with tfvars file
    deps:
      - check-terraform
    vars:
      VAR_FILE: '{{.VAR_FILE | default "terraform.tfvars"}}'
      AUTO_APPROVE: '{{.AUTO_APPROVE | default "false"}}'
    cmds:
      - |
        set -euo pipefail

        # Build command flags
        FLAGS=""
        if [ "{{.AUTO_APPROVE}}" = "true" ]; then
          FLAGS="-auto-approve"
        fi

        # Check if var file exists
        if [ -f "{{.VAR_FILE}}" ]; then
          echo "Running terraform destroy with {{.VAR_FILE}}"
          terraform destroy -var-file={{.VAR_FILE}} $FLAGS
        else
          echo "Running terraform destroy (no var file found)"
          terraform destroy $FLAGS
        fi
    silent: false

  terraform-refresh:
    desc: Refresh Terraform state
    deps:
      - check-terraform
    vars:
      VAR_FILE: '{{.VAR_FILE | default "terraform.tfvars"}}'
    cmds:
      - |
        set -euo pipefail

        # Check if var file exists
        if [ -f "{{.VAR_FILE}}" ]; then
          echo "Running terraform refresh with {{.VAR_FILE}}"
          terraform refresh -var-file={{.VAR_FILE}}
        else
          echo "Running terraform refresh (no var file found)"
          terraform refresh
        fi
    silent: false

  terraform-output:
    desc: Show Terraform outputs
    deps:
      - check-terraform
    vars:
      OUTPUT: '{{.OUTPUT | default ""}}'
      FORMAT: '{{.FORMAT | default ""}}'
    cmds:
      - |
        set -euo pipefail

        FLAGS=""
        if [ -n "{{.FORMAT}}" ]; then
          FLAGS="-{{.FORMAT}}"
        fi

        if [ -n "{{.OUTPUT}}" ]; then
          terraform output $FLAGS {{.OUTPUT}}
        else
          terraform output $FLAGS
        fi
    silent: false

  terraform-import:
    desc: Import existing infrastructure into Terraform state
    deps:
      - check-terraform
    vars:
      RESOURCE: '{{.RESOURCE}}'
      ID: '{{.ID}}'
      VAR_FILE: '{{.VAR_FILE | default "terraform.tfvars"}}'
    cmds:
      - |
        set -euo pipefail

        if [ -z "{{.RESOURCE}}" ] || [ -z "{{.ID}}" ]; then
          echo "ERROR: RESOURCE and ID variables are required"
          echo "Usage: task terraform-import RESOURCE=aws_instance.example ID=i-1234567890abcdef0"
          exit 1
        fi

        # Check if var file exists
        if [ -f "{{.VAR_FILE}}" ]; then
          echo "Importing {{.RESOURCE}} with ID {{.ID}} using {{.VAR_FILE}}"
          terraform import -var-file={{.VAR_FILE}} {{.RESOURCE}} {{.ID}}
        else
          echo "Importing {{.RESOURCE}} with ID {{.ID}}"
          terraform import {{.RESOURCE}} {{.ID}}
        fi
    silent: false

  terraform-state-list:
    desc: List resources in Terraform state
    deps:
      - check-terraform
    cmds:
      - terraform state list
    silent: false

  terraform-state-show:
    desc: Show details of a resource in Terraform state
    deps:
      - check-terraform
    vars:
      RESOURCE: '{{.RESOURCE}}'
    cmds:
      - |
        if [ -z "{{.RESOURCE}}" ]; then
          echo "ERROR: RESOURCE variable is required"
          echo "Usage: task terraform-state-show RESOURCE=aws_instance.example"
          exit 1
        fi
        terraform state show {{.RESOURCE}}
    silent: false

  # Composite tasks for common workflows

  tf-init-upgrade:
    desc: Initialize Terraform with upgrade flag
    deps:
      - check-terraform
    cmds:
      - terraform init -upgrade
    silent: false

  tf-check:
    desc: Format and validate Terraform configuration
    cmds:
      - task: format
      - task: validate
      - task: lint
    silent: false

  tf-plan:
    desc: Full Terraform plan workflow (init, format, validate, plan)
    cmds:
      - task: tf-init-upgrade
      - task: tf-check
      - task: terraform-plan
        vars:
          VAR_FILE: '{{.VAR_FILE}}'
          VERBOSE: '{{.VERBOSE}}'
    silent: false

  tf-apply:
    desc: Full Terraform apply workflow (init, format, validate, apply)
    cmds:
      - task: tf-init-upgrade
      - task: tf-check
      - task: terraform-apply
        vars:
          VAR_FILE: '{{.VAR_FILE}}'
          AUTO_APPROVE: '{{.AUTO_APPROVE}}'
          VERBOSE: '{{.VERBOSE}}'
    silent: false

  tf-destroy:
    desc: Full Terraform destroy workflow (init, plan destroy, destroy)
    cmds:
      - task: tf-init-upgrade
      - |
        echo "Planning destroy operation..."
      - terraform plan -destroy -var-file={{.VAR_FILE | default "terraform.tfvars"}}
      - task: terraform-destroy
        vars:
          VAR_FILE: '{{.VAR_FILE}}'
          AUTO_APPROVE: '{{.AUTO_APPROVE}}'
    silent: false
